一种利用硬件保存处理器运行的状态，在处理器同步之后每过一个固定的时间片，将处理器状态写入SM，实时监测两个处理器的工作状态，一旦发现不一致，立即触发错误恢复，将SM内的数据恢复回计算机，将计算机的状态恢复至上次保存的正确状态，重新运行，达到隔离故障、瞬态恢复的目的。 

[![Y3mIq1.png](https://s1.ax1x.com/2020/05/10/Y3mIq1.png)](https://imgchr.com/i/Y3mIq1)

图一：lockstep 计算机恢复机制硬件构成图



SM（Store Memory）的结构：索引 index 地址位 addr 数据位 data 有效位 valid

（1Kbyte as an example 可修改）

索引 index 为读写地址的低9位，作为SM的地址空间

地址位 addr 为该地址的高23位 由地址位和索引位构成读写指令对应的地址

数据位 data 则为该地址对应的数据

有效位 valid 为每次对SM中index写操作时该index的有效位置1

（4路组关联：将4路结构相同的SRAM关联在一起使用同一个index，在index命中后比较4路中的addr，目的是加大读操作的命中）

（在运行状态下处理器写操作写入SM，对内存不进行改变，保证恢复操作尽量少占用系统资源）

[![Y3mORe.png](https://s1.ax1x.com/2020/05/10/Y3mORe.png)](https://imgchr.com/i/Y3mORe)

图二：lockstep恢复SM硬件结构



lockstep模块错误恢复流程：

- 在T0时刻，双处理器同步运行指令，T0时刻结束进入T0的保存状态，保存T0时的寄存器状态。
- T0-T1时间，由于该时间内无写操作，处理器在T1时刻的内存与T0时刻一致，在 T1结束的保存状态，处理器保存T1时的寄存器状态。
- T1-T2时间，存在读操作，无写操作，处理器在T2结束的保存状态保存T2时的寄存器状态。
- T2-T3时间，存在写操作，之后有读该地址的操作。在写操作时，在T3的运行状态，将该写操作将地址数据写入SM内，而保证内存不变。之后的读操作如果命中上次写操作的地址，则从SM中取出该读操作的数据给双处理器。
- 如果该读操作未命中SM，则由内存直接返回读操作的数据。
- 如有其余的写操作则依次写入SM，直到SM写满。处理器直接进行保存状态。
- 如果在T2-T3段发生一个错误，则将处理器的PC跳回T2时的保存值，同时将T2时保存的寄存器值写入处理器寄存器。此时内存没有在保存状态保存，处理器内存状态仍是T2状态的内存，由硬件将SM的valid位清零，使得SM中数据无效。
- 如果运行到T3时刻结束的保存状态下时，处理器保存T3状态下的寄存器，冋时将SM中的数据写入内存。



[![Y3mxsA.png](https://s1.ax1x.com/2020/05/10/Y3mxsA.png)](https://imgchr.com/i/Y3mxsA)

图三：lockstep模块恢复机制的运行流程

### Future Plan

先找自己感兴趣的细节往深入研究